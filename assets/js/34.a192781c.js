(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{394:function(s,a,e){"use strict";e.r(a);var n=e(41),t=Object(n.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"一-赋值-copy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-赋值-copy"}},[s._v("#")]),s._v(" 一.赋值（copy）")]),s._v(" "),e("p",[s._v("赋值是将某一个数值或对象赋给某个变量的过程；")]),s._v(" "),e("ul",[e("li",[s._v("基本数据类型：赋值，赋值之后两个变量互不影响\n"),e("code",[s._v("基本数据类型：undefined，blooean，string，number，null； 复杂数据类型：object，Symbol ；")])]),s._v(" "),e("li",[s._v("引用数据类型：赋址，两个变量具有相同的引用，指向同一个对象，相互之间有影响\n对引用类型进行赋址操作，两个变量指向同一个对象，改变变量a之后会影响变量b，哪怕改变的只是对象a中的基本类型数据。\n"),e("code",[s._v("let a ={ name:'muyiy', book:{ title: \"you don't know js\", price:'4s' } } let b = a; console.log(b); a.name = 'change'; a.book.price ='55'; console.log(a,'a'); console.log(b,'b'); 改变了对象a对象b也跟着改变")])])]),s._v(" "),e("h2",{attrs:{id:"二-浅拷贝-shallow-copy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-浅拷贝-shallow-copy"}},[s._v("#")]),s._v(" 二.浅拷贝（shallow copy）")]),s._v(" "),e("ol",[e("li",[s._v("what's shallow copy\n创建一个新对象，这个新对象有着原始对象属性值的一份精确拷贝，如果属性是基本类型，拷贝的就是基本类型的值，如果属性是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。\n如果浅拷贝，改变基本数据类型不会影响拷贝的基本类型；如果是引用类型改变会影响拷贝引用类型的值；因为他们是有着相同的引用地址；")])]),s._v(" "),e("h2",{attrs:{id:"三-vue计算属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三-vue计算属性"}},[s._v("#")]),s._v(" 三.vue计算属性；")]),s._v(" "),e("ol",[e("li",[s._v("computed计算属性")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("定义一个函数执行；和运用计算属性；两种方式的最终结果确实是完全相同的；然而，不同的是计算属性是基于他们的依赖进行缓存的。只在相关依赖发生改变时他们才会重新求值。这就意味着相关依赖没有发生改变就不会重新求职\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h2",{attrs:{id:"四绑定类名用在组件上"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四绑定类名用在组件上"}},[s._v("#")]),s._v(" 四绑定类名用在组件上")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("Vue.component('my-component',{\n  template:`<p class =\"foo bar\">hi</p>`\n})\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("ul",[e("li",[s._v("然后添加在使用他的时候添加一些class：")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('<my-component class="baz boo"></my-component>\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("ul",[e("li",[s._v("HTML将被选人为：")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('<p class="foo bar baz boo">hi</p>\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h3",{attrs:{id:"五绑定内联样式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五绑定内联样式"}},[s._v("#")]),s._v(" 五绑定内联样式")]),s._v(" "),e("ul",[e("li",[s._v("v-bind:style 的对象语法十分直观--看着非常像css，但其实是一个javascript对象。css属性名可以用驼峰式(camelCase)或横线分隔(kabab-case,记得用单引号括起来)")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("<div v-bind:style=\"{color:activeColor,fontSize:fontSize + 'px'}\"></div>\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h3",{attrs:{id:"事件修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件修饰符"}},[s._v("#")]),s._v(" 事件修饰符")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v(".stop ,.prevent,.capture,.self,.once,.passive\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('<a v-on:click.stop="doThis"></a>\n\n\x3c!-- 提交事件不再重载页面 --\x3e\n<form v-on:submit.prevent="onSubmit"></form>\n\x3c!-- 修饰符可以串联 --\x3e\n<a v-on:click.stop.prevent="doThat"></a>\n\x3c!-- 只有修饰符 --\x3e\n<form v-on:submit.prevent></form>\n\x3c!-- 添加事件监听时使用事件捕获模式 --\x3e\n\x3c!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --\x3e\n<div v-on:click.capture="dothis">.....</div>\n\x3c!-- 只当在 event.target 是当前元素自身时触发处理函数 --\x3e\n\x3c!-- 即事件不是从内部元素触发的 --\x3e\n<div v-on:click.self="dothat"></div>\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br")])]),e("h3",{attrs:{id:"函数的length属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数的length属性"}},[s._v("#")]),s._v(" 函数的length属性")]),s._v(" "),e("ul",[e("li",[s._v("指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数，也就是说，指定了默认值后，length属性将失真。")]),s._v(" "),e("li",[s._v("严格模式\nes5开始，函数内部可以设定为严格模式。")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function doSomething(){\n  'use strict';\n}\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("h3",{attrs:{id:"依赖注入依赖注入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#依赖注入依赖注入"}},[s._v("#")]),s._v(" 依赖注入"),e("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E4%BE%25**9D**%E8%B5%96%E6%B3%A8%E5%85%A5",target:"_blank",rel:"noopener noreferrer"}},[s._v("依赖注入"),e("OutboundLink")],1)]),s._v(" "),e("p",[s._v("如果子组件需要访问父级组件的一个方法或者方法 可以使用两个新的实例选项:"),e("code",[s._v("provide")]),s._v("和"),e("code",[s._v("inject")]),s._v(".")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("provide 选项允许我们允许我们指定我们想要提供给后代组件的数据或方法，\nprovide:function(){\n    return{\n        getMap:this.getMap\n    }\n}\n然后在任何后代组件里，我们都可以使用inject选项来接收指定的我们想要添加在这个实例上的属性：[]\ninject:['getMap']\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br")])])])}),[],!1,null,null,null);a.default=t.exports}}]);