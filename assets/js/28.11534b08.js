(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{387:function(s,e,n){"use strict";n.r(e);var a=n(41),t=Object(a.a)({},(function(){var s=this,e=s.$createElement,n=s._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h2",{attrs:{id:"async函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#async函数"}},[s._v("#")]),s._v(" async函数")]),s._v(" "),n("ol",[n("li",[s._v("含义\n1.1 内置执行器。\nGenerator函数的执行必须靠执行器，所以才有了"),n("code",[s._v("co")]),s._v("模块，而"),n("code",[s._v("async")]),s._v("函数自带执行器，也就是说，async函数的执行，与普通函数一模一样，只要一行。\n1.2 更好的语义\n1.3 更广的试用性\n1.4 返回值是Promise\n"),n("code",[s._v("async")]),s._v("函数的返回值是promise对象。这比Generator函数的返回值是Iterator对象方便多了，你可以用"),n("code",[s._v("then")]),s._v("方法指定下一步的操作。\n进一步说，"),n("code",[s._v("async")]),s._v("函数完全可以看做多个异步操作，包装承德一个Promise对象，而"),n("code",[s._v("await")]),s._v("命令就是内部"),n("code",[s._v("then")]),s._v("命令的语法糠")]),s._v(" "),n("li",[s._v("基本用法\n"),n("code",[s._v("async")]),s._v("函数返回一个Promise对象，可以使用"),n("code",[s._v("then")]),s._v("方法添加回调函数，当函数执行的时候，一旦遇上"),n("code",[s._v("await")]),s._v("就会先返回，等到异步操作完成，在接着执行函数体内后面的语句。\n下面是一个例子。")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("function timeout(ms){\n    return new Promise((resolve)=>{\n        setTimeout(resolve,ms);\n        console.log('111')\n    })\n}\nasync function asyncPrint (value,ms){\n    await timeout(ms);\n    console.log(value);\n}\nasyncPrint('hello world',5000)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br")])]),n("ol",{attrs:{start:"3"}},[n("li",[s._v("语法\n"),n("code",[s._v("async")]),s._v("函数的语法规则总体上比较简单，难点是错误处理机制。")])]),s._v(" "),n("h3",{attrs:{id:"返回promise对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#返回promise对象"}},[s._v("#")]),s._v(" 返回Promise对象")]),s._v(" "),n("p",[n("code",[s._v("async")]),s._v("函数返回一个promise对象\n"),n("code",[s._v("async")]),s._v("函数内部"),n("code",[s._v("return")]),s._v("语句返回的值，会成为"),n("code",[s._v("then")]),s._v("方法回调函数的参数。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("async function f(){\n    return 'hello world'\n}\nf().then(v=>console.log(v))\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("h3",{attrs:{id:"promise对象的状态变化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#promise对象的状态变化"}},[s._v("#")]),s._v(" Promise对象的状态变化")]),s._v(" "),n("p",[n("code",[s._v("async")]),s._v("函数返回的Promise对象，必须等到内部所有"),n("code",[s._v("await")]),s._v("命令后面的Promise对象执行完，才会发生状态改变，除非遇到"),n("code",[s._v("return")]),s._v("语句或者抛出错误，也就是说，只有"),n("code",[s._v("async")]),s._v("函数内部的一部操作执行完，才会执行"),n("code",[s._v("then")]),s._v("方法指定的回调函数。")])])}),[],!1,null,null,null);e.default=t.exports}}]);