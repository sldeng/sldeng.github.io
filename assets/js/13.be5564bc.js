(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{379:function(s,a,e){"use strict";e.r(a);var n=e(41),t=Object(n.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[s._v("#")]),s._v(" 函数")]),s._v(" "),e("h3",{attrs:{id:"介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[s._v("#")]),s._v(" 介绍")]),s._v(" "),e("p",[s._v("函数时JavaScript应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块，在typescript里，虽然已经支持类，命名空间和模块，但函数任然时主要的定义行为的地方，typeScript和JavaScript函数添加了额外的功能，让我们可以更容易地使用。")]),s._v(" "),e("h3",{attrs:{id:"函数-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数-2"}},[s._v("#")]),s._v(" 函数")]),s._v(" "),e("p",[s._v("和JavaScript一样，typescript函数可以创建有名字的函数和匿名函数，你可以随意选择适合应用程序的方式，不论是定义一系列API函数还是只使用一次的函数")]),s._v(" "),e("blockquote",[e("p",[s._v("example")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("    //Named function\n    function add(x,y){\n        \n        return x+y\n    }\n    //Anonmous function\n    let myAdd = function(x,y){return x+y}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br")])]),e("p",[s._v("在JavaScript里，函数可以使用函数体外部的变量，当函数这么做时，我们说它捕获了这些变量，至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习JavaScript和TypeScript会很有帮助")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v(" let z = 100;\n function addToZ(x,y){\n     return x+y+z\n }\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("h3",{attrs:{id:"函数类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数类型"}},[s._v("#")]),s._v(" 函数类型")]),s._v(" "),e("h4",{attrs:{id:"为函数定义类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为函数定义类型"}},[s._v("#")]),s._v(" 为函数定义类型")]),s._v(" "),e("p",[s._v("让我们为上面那个函数添加类型:")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function add(x:number,y:number):number{\n    return x+y\n}\nlet myAdd = function(x:number,y:number):number{return x+ y}\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("我们可以给每个参数添加类型之后再为函数本身添加返回值类型，TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。")]),s._v(" "),e("h4",{attrs:{id:"书写完整函数类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#书写完整函数类型"}},[s._v("#")]),s._v(" 书写完整函数类型")]),s._v(" "),e("p",[s._v("现在我们已经为函数制定了类型，下面让我们书写函数的完整类型。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("let myAdd:(x:number,y:number)=> number = function(x:number,y:number):number {return x + y}\nlet aa = myAdd(1,2)\nconsole.log(aa); //3\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("p",[s._v("函数类型包含两部分:参数类型和返回值类型，当写出完整类型的时候，这两部分都是需要的，我们以参数列表的形式写出参数类型为每个参数指定一个名字和类型。这个名字只是为了增加可读性，我们也可以这么写:")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("let myAdd: (baseValue: number, increment: number) => number =\n    function(x: number, y: number): number { return x + y; };\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("p",[s._v("只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。\n第二部分是返回值类型，对于返回值，我们在函数和返回值类型之前使用(=>)符号，使之清晰明了，如之前提到的，返回值类型是函数类型的必要部分，如果函数没有任何值，你也必须指定返回值类型为void而不能留空。\n函数的类型只是有参数类型和返回值组成的，函数中使用的捕获变量不会体现在类型里。实际上，这些变量是函数的隐藏状态并不是组成API的一部分。")]),s._v(" "),e("h4",{attrs:{id:"推断类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#推断类型"}},[s._v("#")]),s._v(" 推断类型")]),s._v(" "),e("p",[s._v("尝试这个例子的时候，你会返现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，typescript编译器会自动识别出类型:")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("// myAdd has the full function type\nlet myAdd = function(x:number,y:number):number {return x+y};\n// The parameters `x` and `y` have the type number\nlet myAdd:(baseValue:number,increment:number) = >number = function(x,y){return x+y}\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("这叫做‘按上下文归类’，是类型推论的一种，他帮助我们更好地为程序指定类型")]),s._v(" "),e("h4",{attrs:{id:"可选参数和默认参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可选参数和默认参数"}},[s._v("#")]),s._v(" 可选参数和默认参数")]),s._v(" "),e("p",[s._v("TypeScript里的每个函数参数都是必须的，这不是指不能传递null或undefined作为参数，而且说编译器检查用户是否为每个参数都传入了值，编译器会假设只有这些参数会被传递进函数。简短地说，传递给一个函数个数必须与函数期望的参数个数一致。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function buildName(firstName:string,lastName:string){\n    return firstName + '' + lastName;\n}\nlet result1 = buildName('Bob');\nlet result2 = buildName('Bob','Adams','Sr.');\nlet result3 = buildName('Bob','Adams')\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])]),e("p",[s._v("JavaScript里，每个参数都是可选的，可传可不传，没传参的时候，他的值就是undefined，在typeScript里我们可以在参数名旁使用?实现可选参数的功能，比如，我们想让last name 是参数可选的:")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function buildName (firstName:string,lastName?:string){\n    if(lastName){\n        return firstName + '' + lastName\n    }else{\n        return firstName \n    }\n}\nlet result1 = buildName('Bob');\nlet result2 = buildName('Bob','Adams','Sr.');\nlet result3 = buildName('Bob','Adams');\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br")])]),e("p",[s._v("在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略，也就是说可选参数与末尾的默认参数共享参数类型。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function buildName(firstName:string,lastName?:string){\n    //...\n}\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("p",[s._v("和")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function buildName (firstName:string,lastName='Smith'){\n    //...\n}\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("p",[s._v("共享同样的类型(firstName:string,lastName?:string) => string。默认参数的默认值消失了，只保留了他是一个可选参数的信息。\n与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面，如果带默认值的参数出现在必须参数前面,用户必须明确的传入undefined值来获取默认值，例如，我们重写最后一个例子让"),e("code",[s._v("firstName")]),s._v("是带默认值的参数:")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function buildName(firstName = 'will',lastName:string){\n    return firstName + '' + lastName;\n}\nlet result1 = buildName('Bob');\nlet result2 = buildName('Bob','Adams','Sr.');\nlet result3 = buildName('Bob','Adams');\nlet result$ = buildName('Bob',Adams);\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br")])]),e("h4",{attrs:{id:"剩余参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#剩余参数"}},[s._v("#")]),s._v(" 剩余参数")]),s._v(" "),e("p",[s._v("必要参数，默认参数和可选参数有个共同点；他们表示一个参数，有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来，在JavaScrit里，你可以使用arguments来访问所有传入的参数。\n在TypeScript里，你可以把所有参数收集到一个变量里：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('function buildName(firstName: string, ...restOfName: string[]) {\n    return firstName + " " + restOfName.join(" ");\n  }\n  \n//   let employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie");\n  console.log(buildName("Joseph", "Samuel", "Lucas", "MacKinzie"));\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])]),e("p",[s._v("剩余参数会被当作个数不限的可选参数，可以体格都没有，同样也可以有任意个，编译器创建参数数组，名字是你在省略号(...)后面给定的名字，你可以在函数体内使用这个数组。\n这个省略号也会在带有剩余参数的函数类型定义上使用到：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function buildName(firstName:string,...restOfName:string[]){\n    return firstName + '' restOfName.join(' ');\n    let buildNameFun:(fname:string,...rest:string[]) =>string = buildName\n}\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("h4",{attrs:{id:"this参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this参数"}},[s._v("#")]),s._v(" this参数")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("interface Card {\n    suit:string;\n    card:number;\n}\ninterface Deck{\n    suit:string[];\n    cards:number[];\n    createCardPicker(this.Deck):()=>Card;\n}\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br")])])])}),[],!1,null,null,null);a.default=t.exports}}]);