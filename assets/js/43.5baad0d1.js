(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{405:function(e,a,n){"use strict";n.r(a);var t=n(41),s=Object(t.a)({},(function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"语言基础"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#语言基础"}},[e._v("#")]),e._v(" 语言基础")]),e._v(" "),n("h3",{attrs:{id:"_3-1-语法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-语法"}},[e._v("#")]),e._v(" 3.1 语法")]),e._v(" "),n("p",[e._v("ECMASCript的语法很大程度借鉴了C语言和其他类C语言，如java和perl，熟悉这些语言的开发者，应该很容易理解ECMAScript宽松的语法。")]),e._v(" "),n("h4",{attrs:{id:"_3-1-1-区分大小写"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1-区分大小写"}},[e._v("#")]),e._v(" 3.1.1 区分大小写")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("首先知道的是，ECMAScript中一切都区分大小写，无论变量，函数名还是操作符。都区分大小写。换句话说，变量test和变量Test是两个不同的变量。类似地，typeof不能作为函数名。因为他是一个关键字，但typeof是一个完全有效的函数名。\n")])])]),n("h4",{attrs:{id:"_3-1-2-标识符"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-2-标识符"}},[e._v("#")]),e._v(" 3.1.2 标识符")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("所谓标识符，就是变量，函数，属性或函数参数的名称。标识符可以由一或多个下列字符组成；\n+ 第一个字符必须是一个字母，下划线(_)或美元符号($);\n+ 剩下的其他字符可以是字母，下划线，美元符号或数字，\n")])])]),n("p",[e._v("标识符中字母可以是扩展ASCLL中的字母，也可以是Unicode的字母字符，如A和AE。按照惯例，ECMAScript标识符使用驼峰大小写形式，第一个单词的字母小写，后面每个单词的首字母大写如：firstSecond myCar 虽然这种写法并不是强制性的，但因为这种形式跟ECMAScript内置函数和对象的命名方式一致。所以算是最佳实践")]),e._v(" "),n("h4",{attrs:{id:"_3-1-3-注释"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-3-注释"}},[e._v("#")]),e._v(" 3.1.3 注释")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("ECMAScript采用C语言风格的注释，单行注释以两个斜杠字符开头，如\n```\n// 单行注释\n块注释以一个斜杆和一个星号(/*)开头，以他们的反向组合（*/）结尾\n如\n/*this is 多行注释\n*/\n```\n")])])]),n("h4",{attrs:{id:"_3-1-4严格模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-4严格模式"}},[e._v("#")]),e._v(" 3.1.4严格模式")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("ECMAScript5增加了严格模式的概念（strict  mode）的概念。严格模式是一种不同的JavaScript解析和执行模型，ECMAScript3的一些不规范的写法会在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行：\n```\nuse strict\n```\n虽然看起来像个没有赋值给任何变量的字符串，但是它其实是一个预处理指令。任何支持的JavaScript引擎看到它都会切换到严格模式。选择这种语法形式的目的是不破坏ECMAscript语法。也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数整体开头即可：\n```\nfunction doSomething(){\n    'use strict';\n    \x3c!-- 函数体 --\x3e\n}\n严格模式\n```\n严格模式会影响JavaScript执行的很多方面，因此本书用到他时会明确指出来，所有现代浏览器都支持严格模式。\n")])])]),n("h4",{attrs:{id:"_3-1-5语句"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-5语句"}},[e._v("#")]),e._v(" 3.1.5语句")]),e._v(" "),n("p",[e._v("ECMAScript中的语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾，如下面的例子所示：")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let sum  =a +b   //没有分号也有效，但不推荐\nlet diff  =a -b   //加分号有效，推荐\n\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br")])]),n("p",[e._v("即使语句末尾的分号不是必须的，也应该加上。记着加分号有助于防止省略造成的问题，比如可以避免输入内容不完整，此外，加分号也便于开发者通过删除空格来压缩代码（如果没有结尾的分号，只删除空行，则会导致语法错误）。加分号也有助于在某些情况下提升性能，因此解析器会尝试在合适的位置补上分号以纠正语法错误。")]),e._v(" "),n("h3",{attrs:{id:"_3-2-关键字与保留字"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-关键字与保留字"}},[e._v("#")]),e._v(" 3.2 关键字与保留字")]),e._v(" "),n("p",[e._v("ECMA-262描述了一组关键字，这些关键字有特殊用途，比如表示控制语句的开始与结束，或者执行特定的操作，按照规定,保留的关键字不能用作标识符或属性名，")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("break do in typeof\ncase else instanceof var\ncatch export new void\nclass extends return while\nconst finally super with\ncontinue for switch yield\ndebugger function this \ndefault if throw\ndelete import try\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br")])]),n("p",[e._v("以下是ECMA-262第六版为将来保留的所有词汇\n始终保留\nenum\n严格模式下保留\nimplements package public\ninterface protected  static\nlet private\n模块代码中保留\nawait")]),e._v(" "),n("p",[e._v("这些词汇不能用作标识符，但现在还可以用作对象的属性名，一般来说，最好还是不要使用关键字和保留字作为标识符和属性名，以确保兼容过去和未来的的EcmaScript")]),e._v(" "),n("h3",{attrs:{id:"_3-3-变量"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-变量"}},[e._v("#")]),e._v(" 3.3 变量")]),e._v(" "),n("p",[e._v("ECMAScript变量是松散类型的，意思是变量可以保存任何类型的数据，每个变量只不过是一个用于保存任意值的命名占位符，有3个关键字可以声明变量：var，const，let。其中var在ECMAScript的所以版本都可以使用，而const和let只能在ECMAScript6及更晚的版本使用，")]),e._v(" "),n("h4",{attrs:{id:"_3-3-1-var-关键字"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-1-var-关键字"}},[e._v("#")]),e._v(" 3.3.1 var 关键字")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("var 声明作用域\n关键的问题在于，使用var操作符定义的变量会成为包含他的函数的局部变量。")])]),e._v(" "),n("li",[n("p",[e._v("变量提升")])])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" var age;\n console.log(age);\n age =26;\n foo()\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br")])]),n("h4",{attrs:{id:"_3-3-2-let声明"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-2-let声明"}},[e._v("#")]),e._v(" 3.3.2 let声明")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("let 跟var的作用差不多，但有着非常重要的区别，最明显的区别是let声明的范围是块作用域，而var声明的范围是函数作用域。\nlet也不允许同一个块作用域中出现冗余声明。这样会导致报错：\n`\nvar name;\nvar name;\nlet age;\nlet age;\n`\n1. 暂时性死区\n let 与var的另一个重要的区别，就是let声明的变量不会在作用域中被提升。\n")])])]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// console.log(name)\n// var name = 'matt'\nconsole.log(age)\nlet age =26;\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br")])]),n("ol",{attrs:{start:"2"}},[n("li",[e._v("全局声明\n与var关键字不同，使用let在全局作用域中声明的变量不会成为window对象的属性（var声明的变量则会）")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" var name = 'matt';\nconsole.log(window.name)\nlet age = 26;\nconsole.log(window.age)\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br")])]),n("ol",{attrs:{start:"3"}},[n("li",[e._v("条件声明\n在使用var 声明变量时，由于变量会被提升。JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明，因为let的作用域是块，所以不可能检查前面是否已经使用let声明过同名变量，同时也就不可能在没有声明的情况下声明它。")]),e._v(" "),n("li",[e._v("for循环中的let声明\n在let出现之前，for循环定义的迭代变量会渗透到循环体外部")])]),e._v(" "),n("h4",{attrs:{id:"_3-3-3-const声明"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-3-const声明"}},[e._v("#")]),e._v(" 3.3.3 const声明")]),e._v(" "),n("p",[e._v("const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且\n尝试修改 const 声明的变量会导致运行时错误。")]),e._v(" "),n("h3",{attrs:{id:"_3-4数据类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-4数据类型"}},[e._v("#")]),e._v(" 3.4数据类型")]),e._v(" "),n("p",[e._v("ECMAScript有6种简单数据类型(也称原始数据类型)：Undefined，Null,Boolean,Number,String,和Symbol.Symbol是ECMAscript新增的。")]),e._v(" "),n("h4",{attrs:{id:"_3-4-1-typeof操作符"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-1-typeof操作符"}},[e._v("#")]),e._v(" 3.4.1 typeof操作符")]),e._v(" "),n("p",[e._v('因为ECMAScript的类型是松散的，所以需要一种手段来确定任意变量的数据类型，typeof操作符就是为此而生的，对一个值使用typeof操作符.\n "undefined"表示值未定义；\n "boolean"表示值为布尔值；\n "string"表示值为字符串；\n "number"表示值为数值；\n "object"表示值为对象（而不是函数）或 null；  "function"表示值为函数；\n "symbol"表示值为符号。')]),e._v(" "),n("h4",{attrs:{id:"_3-4-2-undefined-类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-2-undefined-类型"}},[e._v("#")]),e._v(" 3.4.2 Undefined 类型")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('Unidefined类型只有一个值，就是特殊值Undefined。当使用var或let声明变量但是没有初始话是，就相当于给变量赋予了Undefined值\nconsole.log(message); // "undefined" \n')])])]),n("p",[e._v('console.log(age); // 报错\n在上面的例子中，第一个 console.log 会指出变量 message 的值，即"undefined"。而第二个\nconsole.log 要输出一个未声明的变量 age 的值，因此会导致报错。对未声明的变量，只能执行一个\n有用的操作，就是对它调用 typeof。（对未声明的变量调用 delete 也不会报错，但这个操作没什么用，\n实际上在严格模式下会抛出错误。）\n在对未初始化的变量调用 typeof 时，返回的结果是"undefined"，但对未声明的变量调用它时，\n返回的结果还是"undefined"，这就有点让人看不懂了。比如下面的例子：\nlet message; // 这个变量被声明了，只是值为 undefined\n// 确保没有声明过这个变量\n// let age\nconsole.log(typeof message); // "undefined"\nconsole.log(typeof age); // "undefined"')]),e._v(" "),n("h4",{attrs:{id:"_3-4-3-null"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-3-null"}},[e._v("#")]),e._v(" 3.4.3 Null")]),e._v(" "),n("p",[e._v('Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给\ntypeof 传一个 null 会返回"object"的原因：\nlet car = null;\nconsole.log(typeof car); // "object"\n在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查\n这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用，比如：\nif (car != null) {\n// car 是一个对象的引用\n}\nundefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等，如下面的例\n子所示：\nconsole.log(null == undefined); // true\n用等于操作符（==）比较 null 和 undefined 始终返回 true。但要注意，这个操作符会为了比较\n而转换它的操作数（本章后面将详细介绍）。\n即使 null 和 undefined 有关系，它们的用途也是完全不一样的。如前所述，永远不必显式地将\n变量值设置为 undefined。但 null 不是这样的。任何时候，只要变量要保存对象，而当时又没有那个\n对象可保存，就要用 null 来填充该变量。这样就可以保持 null 是空对象指针的语义，并进一步将其\n与 undefined 区分开来。\nnull 是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可\n能的值同样是假值。所以一定要明确自己想检测的就是 null 这个字面值，而不仅仅是假值。\nlet message = null;\nlet age;\nif (message) {\n// 这个块不会执行\n}\nif (!message) {\n// 这个块会执行\n}\nif (age) {\n// 这个块不会执行\n}\nif (!age) {\n// 这个块会执行\n} 类型')]),e._v(" "),n("h4",{attrs:{id:"_3-4-4-boolean-类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-4-boolean-类型"}},[e._v("#")]),e._v(" 3.4.4 Boolean 类型")]),e._v(" "),n("p",[e._v('Boolean（布尔值）类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值：true 和 false。\n这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0。下面是给变量赋布尔值的例子：\nlet found = true;\nlet lost = false;\n注意，布尔值字面量 true 和 false 是区分大小写的，因此 True 和 False（及其他大小混写形式）\n是有效的标识符，但不是布尔值。\n虽然布尔值只有两个，但所有其他 ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其\n他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数：\nlet message = "Hello world!";\nlet messageAsBoolean = Boolean(message);\n在这个例子中，字符串 message 会被转换为布尔值并保存在变量 messageAsBoolean 中。\nBoolean()转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。什么值能转换为 true\n或 false 的规则取决于数据类型和实际的值。下表总结了不同类型与布尔值之间的转换规则。\n数据类型 转换为 true 的值 转换为 false 的值\nBoolean true false\nString 非空字符串 ""（空字符串）\nNumber 非零数值（包括无穷值） 0、NaN（参见后面的相关内容）\nObject 任意对象 null\nUndefined N/A（不存在） undefined\n理解以上转换非常重要，因为像 if 等流控制语句会自动执行其他类型值到布尔值的转换，例如：\nlet message = "Hello world!";\nif (message) {\nconsole.log("Value is true");\n}\n在这个例子中，console.log 会输出字符串"Value is true"，因为字符串 message 会被自动\n转换为等价的布尔值 true。由于存在这种自动转换，理解流控制语句中使用的是什么变量就非常重要。\n错误地使用对象而不是布尔值会明显改变应用程序的执行流。')]),e._v(" "),n("h4",{attrs:{id:"_3-4-5"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-5"}},[e._v("#")]),e._v(" 3.4.5")]),e._v(" "),n("p",[e._v("NaN 不是数值(Not a Number)用来表示本来哟啊返回的数值的操作失败；")]),e._v(" "),n("h4",{attrs:{id:"_3-4-7-symbol类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-7-symbol类型"}},[e._v("#")]),e._v(" 3.4.7 Symbol类型")]),e._v(" "),n("h4",{attrs:{id:"_3-4-8-object类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-8-object类型"}},[e._v("#")]),e._v(" 3.4.8 Object类型")]),e._v(" "),n("ul",[n("li",[e._v("constructor：用于创建当前对象的函数。在前面的例子中，这个属性的值是Object()函数。")]),e._v(" "),n("li",[e._v("hasOwnProperty(propertyName)：用于判断当前对象实例（不是原型）上是否存在给定的属性，要检查的属性名必须是字符串或符号。")]),e._v(" "),n("li",[e._v("propertyIsEnumerable(propertyName)：用于判断给定的属性是否可以使用（本章稍后讨\n论的）for-in 语句枚举。与 hasOwnProperty()一样，属性名必须是字符串。")])]),e._v(" "),n("h6",{attrs:{id:"逻辑与"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#逻辑与"}},[e._v("#")]),e._v(" 逻辑与")]),e._v(" "),n("p",[e._v("逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说。如果第一个操作数是false，那么无论第二个操作数是什么值，结果也不可能等于true")]),e._v(" "),n("h6",{attrs:{id:"赋值操作符"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#赋值操作符"}},[e._v("#")]),e._v(" 赋值操作符")]),e._v(" "),n("ul",[n("li",[e._v("乘后赋值（*=）")]),e._v(" "),n("li",[e._v("除后赋值(/=)")]),e._v(" "),n("li",[e._v("取模赋值(%=)")]),e._v(" "),n("li",[e._v("加后赋值(+=)")]),e._v(" "),n("li",[e._v("减后赋值(-=)")]),e._v(" "),n("li",[e._v("左转后赋值(<<=)")]),e._v(" "),n("li",[e._v("右转后赋值(>>=)")]),e._v(" "),n("li",[e._v("无符号右转赋值(>>>=)\n这些操作符仅仅是简写语法。使用它们不会提升性能")])]),e._v(" "),n("h4",{attrs:{id:"for-in语句"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#for-in语句"}},[e._v("#")]),e._v(" for-in语句")]),e._v(" "),n("p",[e._v("for-in语句是一种严格的迭代语句，用于枚举对象中的非符号键属性")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("for (const propName in window) { \n       document.write(propName); \n  }\n\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br")])]),n("h4",{attrs:{id:"for-of语句"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#for-of语句"}},[e._v("#")]),e._v(" for-of语句")]),e._v(" "),n("p",[e._v("for-of 语句是一种严格的迭代语句，用于遍布可迭代对象的元素")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("for (const el of [2,4,6,8]) { \n document.write(el); \n}\n\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br")])]),n("h4",{attrs:{id:"break和continue语句"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#break和continue语句"}},[e._v("#")]),e._v(" break和continue语句")]),e._v(" "),n("p",[e._v("break 和 continue 语句为执行循环代码提供了更严格的控制手段。其中，break 语句用于立即退\n出循环，强制执行循环后的下一条语句。而 continue 语句也用于立即退出循环，但会再次从循环顶部\n开始执行。")]),e._v(" "),n("h4",{attrs:{id:"标签语句"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#标签语句"}},[e._v("#")]),e._v(" 标签语句")]),e._v(" "),n("p",[n("code",[e._v("let num =0; outermost: for(let i=0;i<10;i++>){ for(let j = 0; j < 10; j++){ if (i == 5 && j == 5) { break outermost; } num++; } } console.log(num)")])]),e._v(" "),n("h4",{attrs:{id:"with语句"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#with语句"}},[e._v("#")]),e._v(" with语句")]),e._v(" "),n("p",[e._v("with语句的用途是将代码作用域设置为特定的对象，其语法是:\n"),n("code",[e._v("with(expression) statement")])])])}),[],!1,null,null,null);a.default=s.exports}}]);