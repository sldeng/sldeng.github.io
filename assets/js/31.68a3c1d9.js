(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{389:function(e,t,s){"use strict";s.r(t);var n=s(41),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"js-eventloop-事件循环机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js-eventloop-事件循环机制"}},[e._v("#")]),e._v(" js EventLoop 事件循环机制：")]),e._v(" "),s("ul",[s("li",[e._v("JavaScript的事件分两种，宏任务（macro-task）和微任务（micro-task）")])]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("宏任务")]),e._v("：包括整体代码script，setTimeout，setInterval")]),e._v(" "),s("li",[s("strong",[e._v("微任务")]),e._v("：Promise.then(非new Promise)，process.nextTick(node中)")]),e._v(" "),s("li",[e._v("事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入Event Table并注册函数，异步事件完成后，会将回调函数放入Event Queue中（宏任务和微任务是不同的Event Queue），同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。\n注意：setTimeout并不是直接的把你的回调函数放进上述的异步队列中去，而是定时器的时间到了之后，把回调函数放到执行异步队列中去，如果此时这个队列已经有很多任务了，那就排在他们的后面，这也就解释了为什么setTimeout为什么不能精确的执行的问题了，setTimeout执行需要满足两个条件：")])]),e._v(" "),s("blockquote",[s("p",[e._v("1.主线程必须是空闲的状态，如果到时间了，主进程不空闲也不会执行你的回调函数\n2.这个回调函数需要等到插入异步队列时前面的异步函数都执行完了，才会执行\n上面是比较官方的解释，说一下")])])])}),[],!1,null,null,null);t.default=o.exports}}]);